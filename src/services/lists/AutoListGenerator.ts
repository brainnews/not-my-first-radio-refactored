/**
 * Auto-generated station list service for creating curated collections
 */

import { LocalStation } from '@/types/station';

export interface AutoGeneratedList {
  id: string;
  title: string;
  stations: LocalStation[];
  type: 'genre' | 'country' | 'recent' | 'quality';
}

export interface AutoListGeneratorConfig {
  minStationsForGenre?: number;
  maxListsForSmallLibrary?: number;
  maxListsForLargeLibrary?: number;
  smallLibraryThreshold?: number;
}

/**
 * Generates auto-curated station lists based on user's library
 */
export class AutoListGenerator {
  private config: Required<AutoListGeneratorConfig>;

  constructor(config: AutoListGeneratorConfig = {}) {
    this.config = {
      minStationsForGenre: config.minStationsForGenre ?? 3,
      maxListsForSmallLibrary: config.maxListsForSmallLibrary ?? 2,
      maxListsForLargeLibrary: config.maxListsForLargeLibrary ?? 4,
      smallLibraryThreshold: config.smallLibraryThreshold ?? 15,
    };
  }

  /**
   * Clean station name by removing common metadata patterns
   */
  public cleanStationName(name: string): string {
    // First check if the name contains a call sign pattern
    const callSignMatch = name.match(/\b([WKCN][A-Z]{2,3})\b/i);
    if (callSignMatch) {
      return callSignMatch[1].toUpperCase();
    }

    return name
      // Remove bitrate information: "128k", "320 kbps", etc.
      .replace(/\s*\d+\s*k(bps)?/gi, '')
      // Remove "- Radio" suffix
      .replace(/\s*-\s*radio$/i, '')
      // Remove "Radio" prefix/suffix
      .replace(/^radio\s*/i, '')
      .replace(/\s*radio$/i, '')
      // Remove bracketed information like [128k], (Live), etc.
      .replace(/\s*[\[\(][^\[\]()]*[\]\)]/g, '')
      // Remove streaming quality indicators
      .replace(/\s*(hd|hq|high\s*quality|live|stream|streaming)/gi, '')
      // Remove FM/AM when clearly frequency markers (with numbers or standalone)
      .replace(/\s+\d+\.?\d*\s*(fm|am)\b/gi, '') // "89.5 FM", "1010 AM"
      .replace(/\s+(fm|am)\s+\d+\.?\d*/gi, '') // "FM 89.5", "AM 1010"
      .replace(/\b(fm|am)\s*\d+\.?\d*/gi, '') // "FM89.5", "AM1010"
      .replace(/\d+\.?\d*\s*(fm|am)\b/gi, '') // "89.5FM", "1010AM"
      // Remove other broadcasting terms (but not FM/AM which are handled above)
      .replace(/\s*(web|online|internet|digital)/gi, '')
      // Clean up extra whitespace
      .replace(/\s+/g, ' ')
      .trim();
  }

  /**
   * Extract genre keywords from station name and tags
   */
  private extractGenreKeywords(station: LocalStation): string[] {
    const text = `${this.cleanStationName(station.name)} ${station.tags || ''}`.toLowerCase();
    const keywords: string[] = [];

    // Classical music patterns
    if (/\b(classical|classic|symphony|baroque|romantic|opera|chamber|philharmonic|orchestra)\b/i.test(text)) {
      keywords.push('classical');
    }

    // Jazz patterns
    if (/\b(jazz|blues|smooth|bebop|swing|fusion|latin jazz)\b/i.test(text)) {
      keywords.push('jazz');
    }

    // Rock patterns  
    if (/\b(rock|alternative|indie|metal|punk|grunge|hard rock|classic rock)\b/i.test(text)) {
      keywords.push('rock');
    }

    return keywords;
  }

  /**
   * Calculate genre match score for a station
   */
  private calculateGenreScore(station: LocalStation, targetGenre: string): number {
    let score = 0;
    const name = this.cleanStationName(station.name).toLowerCase();
    const tags = (station.tags || '').toLowerCase();

    // Exact genre match in name (highest priority)
    if (name.includes(targetGenre)) {
      score += 10;
    }

    // Genre match in tags
    if (tags.includes(targetGenre)) {
      score += 8;
    }

    // Related genre keywords
    const keywords = this.extractGenreKeywords(station);
    if (keywords.includes(targetGenre)) {
      score += 6;
    }

    // Boost score for higher quality stations
    if (station.bitrate && station.bitrate >= 192) {
      score += 2;
    }

    // Boost score for stations with more votes/clicks (popularity)
    if (station.votes && station.votes > 10) {
      score += 1;
    }

    return score;
  }

  /**
   * Generate genre-based station list
   */
  private generateGenreList(stations: LocalStation[], genre: string): AutoGeneratedList | null {
    const listId = `genre-${genre}`;

    // Score and filter stations for this genre
    const candidateStations = stations
      .map(station => ({
        station,
        score: this.calculateGenreScore(station, genre)
      }))
      .filter(item => item.score > 5) // Minimum threshold for genre match
      .sort((a, b) => b.score - a.score) // Highest scoring first
      .slice(0, 8) // Limit to 8 stations per list
      .map(item => item.station);

    // Check if we have enough stations for this genre
    if (candidateStations.length < this.config.minStationsForGenre) {
      return null;
    }

    // Generate list metadata
    const metadata = this.getGenreMetadata(genre);
    
    return {
      id: listId,
      title: metadata.title,
      stations: candidateStations,
      type: 'genre'
    };
  }

  /**
   * Get metadata for genre lists
   */
  private getGenreMetadata(genre: string): { title: string } {
    const metadata = {
      classical: {
        title: 'Classical'
      },
      jazz: {
        title: 'Jazz & Blues'
      },
      rock: {
        title: 'Rock'
      }
    };

    return metadata[genre as keyof typeof metadata] || {
      title: genre.charAt(0).toUpperCase() + genre.slice(1)
    };
  }

  /**
   * Generate all auto-generated lists for the current station library
   */
  generateLists(stations: LocalStation[]): AutoGeneratedList[] {
    if (stations.length === 0) {
      return [];
    }

    const lists: AutoGeneratedList[] = [];
    const maxLists = stations.length <= this.config.smallLibraryThreshold 
      ? this.config.maxListsForSmallLibrary 
      : this.config.maxListsForLargeLibrary;

    // Generate genre-based lists (Phase 1 focus)
    const genres = ['classical', 'jazz', 'rock'];
    
    for (const genre of genres) {
      if (lists.length >= maxLists) break;
      
      const genreList = this.generateGenreList(stations, genre);
      if (genreList) {
        lists.push(genreList);
      }
    }

    return lists;
  }

}

// Export singleton instance
export const autoListGenerator = new AutoListGenerator();