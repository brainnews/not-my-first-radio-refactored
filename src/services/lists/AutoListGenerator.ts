/**
 * Auto-generated station list service for creating curated collections
 */

import { LocalStation } from '@/types/station';
import { getStorageItem, setStorageItem, StorageKeys } from '@/utils/storage';

export interface AutoGeneratedList {
  id: string;
  title: string;
  stations: LocalStation[];
  type: 'genre' | 'country' | 'recent' | 'least-listened';
}

export interface AutoListGeneratorConfig {
  minStationsForGenre?: number;
  maxLists?: number;
  minStationsForCountry?: number;
  minStationsForBehavior?: number;
  recentDaysThreshold?: number;
}

/**
 * Generates auto-curated station lists based on user's library
 */
export class AutoListGenerator {
  private config: Required<AutoListGeneratorConfig>;

  constructor(config: AutoListGeneratorConfig = {}) {
    this.config = {
      minStationsForGenre: config.minStationsForGenre ?? 3,
      maxLists: config.maxLists ?? 4,
      minStationsForCountry: config.minStationsForCountry ?? 4,
      minStationsForBehavior: config.minStationsForBehavior ?? 3,
      recentDaysThreshold: config.recentDaysThreshold ?? 30,
    };
  }

  /**
   * Clean station name by removing common metadata patterns
   */
  public cleanStationName(name: string): string {
    // First check if the name contains a call sign pattern
    const callSignMatch = name.match(/\b([WKCN][A-Z]{2,3})\b/i);
    if (callSignMatch) {
      return callSignMatch[1].toUpperCase();
    }

    return name
      // Remove bitrate information: "128k", "320 kbps", etc.
      .replace(/\s*\d+\s*k(bps)?/gi, '')
      // Remove "- Radio" suffix
      .replace(/\s*-\s*radio$/i, '')
      // Remove "Radio" prefix/suffix
      .replace(/^radio\s*/i, '')
      .replace(/\s*radio$/i, '')
      // Remove bracketed information like [128k], (Live), etc.
      .replace(/\s*[\[\(][^\[\]()]*[\]\)]/g, '')
      // Remove streaming quality indicators
      .replace(/\s*(hd|hq|high\s*quality|live|stream|streaming)/gi, '')
      // Remove FM/AM when clearly frequency markers (with numbers or standalone)
      .replace(/\s+\d+\.?\d*\s*(fm|am)\b/gi, '') // "89.5 FM", "1010 AM"
      .replace(/\s+(fm|am)\s+\d+\.?\d*/gi, '') // "FM 89.5", "AM 1010"
      .replace(/\b(fm|am)\s*\d+\.?\d*/gi, '') // "FM89.5", "AM1010"
      .replace(/\d+\.?\d*\s*(fm|am)\b/gi, '') // "89.5FM", "1010AM"
      // Remove other broadcasting terms (but not FM/AM which are handled above)
      .replace(/\s*(web|online|internet|digital)/gi, '')
      // Clean up extra whitespace
      .replace(/\s+/g, ' ')
      .trim();
  }

  /**
   * Extract genre keywords from station name and tags
   */
  private extractGenreKeywords(station: LocalStation): string[] {
    const text = `${this.cleanStationName(station.name)} ${station.tags || ''}`.toLowerCase();
    const keywords: string[] = [];

    // Classical music patterns
    if (/\b(classical|classic|symphony|baroque|romantic|opera|chamber|philharmonic|orchestra)\b/i.test(text)) {
      keywords.push('classical');
    }

    // Jazz patterns
    if (/\b(jazz|blues|smooth|bebop|swing|fusion|latin jazz)\b/i.test(text)) {
      keywords.push('jazz');
    }

    // Rock patterns  
    if (/\b(rock|alternative|indie|metal|punk|grunge|hard rock|classic rock)\b/i.test(text)) {
      keywords.push('rock');
    }

    return keywords;
  }

  /**
   * Calculate genre match score for a station
   */
  private calculateGenreScore(station: LocalStation, targetGenre: string): number {
    let score = 0;
    const name = this.cleanStationName(station.name).toLowerCase();
    const tags = (station.tags || '').toLowerCase();

    // Exact genre match in name (highest priority)
    if (name.includes(targetGenre)) {
      score += 10;
    }

    // Genre match in tags
    if (tags.includes(targetGenre)) {
      score += 8;
    }

    // Related genre keywords
    const keywords = this.extractGenreKeywords(station);
    if (keywords.includes(targetGenre)) {
      score += 6;
    }

    // Boost score for higher quality stations
    if (station.bitrate && station.bitrate >= 192) {
      score += 2;
    }

    // Boost score for stations with more votes/clicks (popularity)
    if (station.votes && station.votes > 10) {
      score += 1;
    }

    return score;
  }

  /**
   * Generate genre-based station list
   */
  private generateGenreList(stations: LocalStation[], genre: string): AutoGeneratedList | null {
    const listId = `genre-${genre}`;

    // Score and filter stations for this genre
    const candidateStations = stations
      .map(station => ({
        station,
        score: this.calculateGenreScore(station, genre)
      }))
      .filter(item => item.score > 5) // Minimum threshold for genre match
      .sort((a, b) => b.score - a.score) // Highest scoring first
      .slice(0, 8) // Limit to 8 stations per list
      .map(item => item.station);

    // Check if we have enough stations for this genre
    if (candidateStations.length < this.config.minStationsForGenre) {
      return null;
    }

    // Generate list metadata
    const metadata = this.getGenreMetadata(genre);
    
    return {
      id: listId,
      title: metadata.title,
      stations: candidateStations,
      type: 'genre'
    };
  }

  /**
   * Get metadata for genre lists
   */
  private getGenreMetadata(genre: string): { title: string } {
    const metadata = {
      classical: {
        title: 'Classical'
      },
      jazz: {
        title: 'Jazz & Blues'
      },
      rock: {
        title: 'Rock'
      }
    };

    return metadata[genre as keyof typeof metadata] || {
      title: genre.charAt(0).toUpperCase() + genre.slice(1)
    };
  }

  /**
   * Generate country-based stations list
   */
  private generateCountryList(stations: LocalStation[]): AutoGeneratedList | null {
    // Group stations by country
    const countryGroups: Record<string, LocalStation[]> = {};
    
    stations.forEach(station => {
      if (!station.countrycode) return;
      
      const country = station.countrycode.toUpperCase();
      if (!countryGroups[country]) {
        countryGroups[country] = [];
      }
      countryGroups[country].push(station);
    });

    // Find the country with the most stations (but not overwhelming majority)
    const sortedCountries = Object.entries(countryGroups)
      .filter(([, stationList]) => stationList.length >= this.config.minStationsForCountry)
      .sort(([, a], [, b]) => b.length - a.length)
      .slice(0, 3); // Top 3 countries max

    if (sortedCountries.length === 0) {
      return null;
    }

    // Select the first country that isn't too dominant (less than 70% of all stations)
    const totalStations = stations.length;
    const selectedCountry = sortedCountries.find(([, stationList]) => 
      stationList.length < totalStations * 0.7
    ) || sortedCountries[0];

    const [countryCode, countryStations] = selectedCountry;
    
    // Get country name (simple mapping for common codes)
    const countryNames: Record<string, string> = {
      'US': 'United States',
      'GB': 'United Kingdom',
      'DE': 'Germany',
      'FR': 'France',
      'CA': 'Canada',
      'AU': 'Australia',
      'IT': 'Italy',
      'ES': 'Spain',
      'NL': 'Netherlands',
      'SE': 'Sweden',
      'NO': 'Norway',
      'DK': 'Denmark',
      'FI': 'Finland',
      'CH': 'Switzerland',
      'AT': 'Austria',
      'BE': 'Belgium',
      'IE': 'Ireland',
      'PL': 'Poland',
      'CZ': 'Czech Republic',
      'JP': 'Japan',
      'KR': 'South Korea',
      'BR': 'Brazil',
      'AR': 'Argentina',
      'MX': 'Mexico'
    };

    const countryName = countryNames[countryCode] || countryCode;
    const stationsToShow = countryStations
      .sort((a, b) => (b.votes || 0) - (a.votes || 0)) // Sort by popularity
      .slice(0, 8);

    return {
      id: `country-${countryCode.toLowerCase()}`,
      title: `From ${countryName}`,
      stations: stationsToShow,
      type: 'country'
    };
  }

  /**
   * Generate least listened stations list
   */
  private generateLeastListenedList(stations: LocalStation[]): AutoGeneratedList | null {
    const listeningTimes = getStorageItem<Record<string, number>>(StorageKeys.STATION_LISTENING_TIMES, {});
    
    // Filter stations that have been played but with minimal listening time (under 5 minutes total)
    const leastListenedStations = stations
      .filter(station => {
        const stationKey = station.stationuuid || station.url;
        const totalTime = listeningTimes[stationKey] || 0;
        return totalTime > 0 && totalTime < 300; // Less than 5 minutes (300 seconds)
      })
      .sort((a, b) => {
        // Sort by least listened time first
        const aKey = a.stationuuid || a.url;
        const bKey = b.stationuuid || b.url;
        const aTime = listeningTimes[aKey] || 0;
        const bTime = listeningTimes[bKey] || 0;
        return aTime - bTime;
      })
      .slice(0, 8);

    if (leastListenedStations.length < this.config.minStationsForBehavior) {
      return null;
    }

    return {
      id: 'least-listened',
      title: 'Rediscover These',
      stations: leastListenedStations,
      type: 'least-listened'
    };
  }

  /**
   * Generate recently added stations list
   */
  private generateRecentList(stations: LocalStation[]): AutoGeneratedList | null {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - this.config.recentDaysThreshold);
    const cutoffTime = cutoffDate.getTime();

    // Filter stations added within the threshold (use dateAdded if available, fallback to id timestamp or current time)
    const recentStations = stations
      .filter(station => {
        const addedTime = station.dateAdded 
          ? new Date(station.dateAdded).getTime()
          : (station.id ? parseInt(station.id) : Date.now());
        return addedTime >= cutoffTime;
      })
      .sort((a, b) => {
        // Sort by most recently added
        const aTime = a.dateAdded ? new Date(a.dateAdded).getTime() : (a.id ? parseInt(a.id) : 0);
        const bTime = b.dateAdded ? new Date(b.dateAdded).getTime() : (b.id ? parseInt(b.id) : 0);
        return bTime - aTime;
      })
      .slice(0, 8);

    if (recentStations.length < this.config.minStationsForBehavior) {
      return null;
    }

    return {
      id: 'recent-stations',
      title: 'Recently Added',
      stations: recentStations,
      type: 'recent'
    };
  }

  /**
   * Generate all auto-generated lists for the current station library
   */
  generateLists(stations: LocalStation[]): AutoGeneratedList[] {
    if (stations.length === 0) {
      return [];
    }

    const lists: AutoGeneratedList[] = [];

    // Get dismissal state
    const dismissedLists = getStorageItem<string[]>(StorageKeys.AUTO_GENERATED_LISTS_DISMISSED, []);

    // Generate all possible lists
    const candidateLists: AutoGeneratedList[] = [];
    
    // 1. Recently Added
    if (!dismissedLists.includes('recent-stations')) {
      const recentList = this.generateRecentList(stations);
      if (recentList) {
        candidateLists.push(recentList);
      }
    }
    
    // 2. Least Listened
    if (!dismissedLists.includes('least-listened')) {
      const leastListenedList = this.generateLeastListenedList(stations);
      if (leastListenedList) {
        candidateLists.push(leastListenedList);
      }
    }
    
    // 3. Country-based
    const countryList = this.generateCountryList(stations);
    if (countryList && !dismissedLists.includes(countryList.id)) {
      candidateLists.push(countryList);
    }
    
    // 4. Genre-based lists
    const genres = ['classical', 'jazz', 'rock'];
    for (const genre of genres) {
      const listId = `genre-${genre}`;
      if (!dismissedLists.includes(listId)) {
        const genreList = this.generateGenreList(stations, genre);
        if (genreList) {
          candidateLists.push(genreList);
        }
      }
    }
    
    // Sort by station count (most stations first) and take top 4
    candidateLists
      .sort((a, b) => b.stations.length - a.stations.length)
      .slice(0, this.config.maxLists)
      .forEach(list => lists.push(list));

    return lists;
  }

  /**
   * Dismiss an auto-generated list
   */
  dismissList(listId: string): void {
    const dismissedLists = getStorageItem<string[]>(StorageKeys.AUTO_GENERATED_LISTS_DISMISSED, []);
    if (!dismissedLists.includes(listId)) {
      dismissedLists.push(listId);
      setStorageItem(StorageKeys.AUTO_GENERATED_LISTS_DISMISSED, dismissedLists);
    }
  }

  /**
   * Restore a dismissed auto-generated list
   */
  restoreList(listId: string): void {
    const dismissedLists = getStorageItem<string[]>(StorageKeys.AUTO_GENERATED_LISTS_DISMISSED, []);
    const updatedLists = dismissedLists.filter(id => id !== listId);
    setStorageItem(StorageKeys.AUTO_GENERATED_LISTS_DISMISSED, updatedLists);
  }

  /**
   * Get list of dismissed list IDs
   */
  getDismissedLists(): string[] {
    return getStorageItem<string[]>(StorageKeys.AUTO_GENERATED_LISTS_DISMISSED, []);
  }

  /**
   * Reset all dismissed lists (restore all auto-generated lists)
   */
  resetDismissedLists(): void {
    setStorageItem(StorageKeys.AUTO_GENERATED_LISTS_DISMISSED, []);
  }

}

// Export singleton instance
export const autoListGenerator = new AutoListGenerator();