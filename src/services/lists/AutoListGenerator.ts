/**
 * Auto-generated station list service for creating curated collections
 */

import { LocalStation, StationListeningTimes, ListRotationState } from '@/types/station';
import { getStorageItem, setStorageItem, StorageKeys } from '@/utils/storage';

export interface AutoGeneratedList {
  id: string;
  title: string;
  stations: LocalStation[];
  type: 'genre' | 'country' | 'recent' | 'least-listened' | 'behavioral';
}

export interface AutoListGeneratorConfig {
  minStationsForGenre?: number;
  maxLists?: number;
  minStationsForCountry?: number;
  minStationsForBehavior?: number;
  recentDaysThreshold?: number;
  rotationIntervalDays?: number;
  minSessionDataDays?: number;
  behavioralAnalysisEnabled?: boolean;
}

/**
 * Generates auto-curated station lists based on user's library
 */
export class AutoListGenerator {
  private config: Required<AutoListGeneratorConfig>;

  constructor(config: AutoListGeneratorConfig = {}) {
    this.config = {
      minStationsForGenre: config.minStationsForGenre ?? 3,
      maxLists: config.maxLists ?? 4,
      minStationsForCountry: config.minStationsForCountry ?? 4,
      minStationsForBehavior: config.minStationsForBehavior ?? 3,
      recentDaysThreshold: config.recentDaysThreshold ?? 30,
      rotationIntervalDays: config.rotationIntervalDays ?? 7,
      minSessionDataDays: config.minSessionDataDays ?? 7,
      behavioralAnalysisEnabled: config.behavioralAnalysisEnabled ?? true,
    };
  }

  /**
   * Clean station name by removing common metadata patterns
   */
  public cleanStationName(name: string): string {
    // First check if the name contains a call sign pattern
    const callSignMatch = name.match(/\b([WKCN][A-Z]{2,3})\b/i);
    if (callSignMatch) {
      return callSignMatch[1].toUpperCase();
    }

    return name
      // Remove bitrate information: "128k", "320 kbps", etc.
      .replace(/\s*\d+\s*k(bps)?/gi, '')
      // Remove "- Radio" suffix
      .replace(/\s*-\s*radio$/i, '')
      // Remove "Radio" prefix/suffix
      .replace(/^radio\s*/i, '')
      .replace(/\s*radio$/i, '')
      // Remove bracketed information like [128k], (Live), etc.
      .replace(/\s*[\[\(][^\[\]()]*[\]\)]/g, '')
      // Remove streaming quality indicators
      .replace(/\s*(hd|hq|high\s*quality|live|stream|streaming)/gi, '')
      // Remove FM/AM when clearly frequency markers (with numbers or standalone)
      .replace(/\s+\d+\.?\d*\s*(fm|am)\b/gi, '') // "89.5 FM", "1010 AM"
      .replace(/\s+(fm|am)\s+\d+\.?\d*/gi, '') // "FM 89.5", "AM 1010"
      .replace(/\b(fm|am)\s*\d+\.?\d*/gi, '') // "FM89.5", "AM1010"
      .replace(/\d+\.?\d*\s*(fm|am)\b/gi, '') // "89.5FM", "1010AM"
      // Remove other broadcasting terms (but not FM/AM which are handled above)
      .replace(/\s*(web|online|internet|digital)/gi, '')
      // Clean up extra whitespace
      .replace(/\s+/g, ' ')
      .trim();
  }

  /**
   * Extract genre keywords from station name and tags
   */
  private extractGenreKeywords(station: LocalStation): string[] {
    const text = `${this.cleanStationName(station.name)} ${station.tags || ''}`.toLowerCase();
    const keywords: string[] = [];

    // Classical music patterns
    if (/\b(classical|classic|symphony|baroque|romantic|opera|chamber|philharmonic|orchestra)\b/i.test(text)) {
      keywords.push('classical');
    }

    // Jazz patterns
    if (/\b(jazz|blues|smooth|bebop|swing|fusion|latin jazz)\b/i.test(text)) {
      keywords.push('jazz');
    }

    // Rock patterns  
    if (/\b(rock|alternative|indie|metal|punk|grunge|hard rock|classic rock)\b/i.test(text)) {
      keywords.push('rock');
    }

    return keywords;
  }

  /**
   * Calculate genre match score for a station
   */
  private calculateGenreScore(station: LocalStation, targetGenre: string): number {
    let score = 0;
    const name = this.cleanStationName(station.name).toLowerCase();
    const tags = (station.tags || '').toLowerCase();

    // Exact genre match in name (highest priority)
    if (name.includes(targetGenre)) {
      score += 10;
    }

    // Genre match in tags
    if (tags.includes(targetGenre)) {
      score += 8;
    }

    // Related genre keywords
    const keywords = this.extractGenreKeywords(station);
    if (keywords.includes(targetGenre)) {
      score += 6;
    }

    // Boost score for higher quality stations
    if (station.bitrate && station.bitrate >= 192) {
      score += 2;
    }

    // Boost score for stations with more votes/clicks (popularity)
    if (station.votes && station.votes > 10) {
      score += 1;
    }

    return score;
  }

  /**
   * Generate genre-based station list
   */
  private generateGenreList(stations: LocalStation[], genre: string): AutoGeneratedList | null {
    const listId = `genre-${genre}`;

    // Score and filter stations for this genre
    const candidateStations = stations
      .map(station => ({
        station,
        score: this.calculateGenreScore(station, genre)
      }))
      .filter(item => item.score > 5) // Minimum threshold for genre match
      .sort((a, b) => b.score - a.score) // Highest scoring first
      .slice(0, 8) // Limit to 8 stations per list
      .map(item => item.station);

    // Check if we have enough stations for this genre
    if (candidateStations.length < this.config.minStationsForGenre) {
      return null;
    }

    // Generate list metadata
    const metadata = this.getGenreMetadata(genre);
    
    return {
      id: listId,
      title: metadata.title,
      stations: candidateStations,
      type: 'genre'
    };
  }

  /**
   * Get metadata for genre lists
   */
  private getGenreMetadata(genre: string): { title: string } {
    const metadata = {
      classical: {
        title: 'Classical'
      },
      jazz: {
        title: 'Jazz & Blues'
      },
      rock: {
        title: 'Rock'
      }
    };

    return metadata[genre as keyof typeof metadata] || {
      title: genre.charAt(0).toUpperCase() + genre.slice(1)
    };
  }

  /**
   * Generate country-based stations list
   */
  private generateCountryList(stations: LocalStation[]): AutoGeneratedList | null {
    // Group stations by country
    const countryGroups: Record<string, LocalStation[]> = {};
    
    stations.forEach(station => {
      if (!station.countrycode) return;
      
      const country = station.countrycode.toUpperCase();
      if (!countryGroups[country]) {
        countryGroups[country] = [];
      }
      countryGroups[country].push(station);
    });

    // Find the country with the most stations (but not overwhelming majority)
    const sortedCountries = Object.entries(countryGroups)
      .filter(([, stationList]) => stationList.length >= this.config.minStationsForCountry)
      .sort(([, a], [, b]) => b.length - a.length)
      .slice(0, 3); // Top 3 countries max

    if (sortedCountries.length === 0) {
      return null;
    }

    // Select the first country that isn't too dominant (less than 70% of all stations)
    const totalStations = stations.length;
    const selectedCountry = sortedCountries.find(([, stationList]) => 
      stationList.length < totalStations * 0.7
    ) || sortedCountries[0];

    const [countryCode, countryStations] = selectedCountry;
    
    // Get country name (simple mapping for common codes)
    const countryNames: Record<string, string> = {
      'US': 'United States',
      'GB': 'United Kingdom',
      'DE': 'Germany',
      'FR': 'France',
      'CA': 'Canada',
      'AU': 'Australia',
      'IT': 'Italy',
      'ES': 'Spain',
      'NL': 'Netherlands',
      'SE': 'Sweden',
      'NO': 'Norway',
      'DK': 'Denmark',
      'FI': 'Finland',
      'CH': 'Switzerland',
      'AT': 'Austria',
      'BE': 'Belgium',
      'IE': 'Ireland',
      'PL': 'Poland',
      'CZ': 'Czech Republic',
      'JP': 'Japan',
      'KR': 'South Korea',
      'BR': 'Brazil',
      'AR': 'Argentina',
      'MX': 'Mexico'
    };

    const countryName = countryNames[countryCode] || countryCode;
    const stationsToShow = countryStations
      .sort((a, b) => (b.votes || 0) - (a.votes || 0)) // Sort by popularity
      .slice(0, 8);

    return {
      id: `country-${countryCode.toLowerCase()}`,
      title: `From ${countryName}`,
      stations: stationsToShow,
      type: 'country'
    };
  }

  /**
   * Generate least listened stations list
   */
  private generateLeastListenedList(stations: LocalStation[]): AutoGeneratedList | null {
    const listeningTimes = getStorageItem<Record<string, number>>(StorageKeys.STATION_LISTENING_TIMES, {});
    
    // Filter stations that have been played but with minimal listening time (under 5 minutes total)
    const leastListenedStations = stations
      .filter(station => {
        const stationKey = station.stationuuid || station.url;
        const totalTime = listeningTimes[stationKey] || 0;
        return totalTime > 0 && totalTime < 300; // Less than 5 minutes (300 seconds)
      })
      .sort((a, b) => {
        // Sort by least listened time first
        const aKey = a.stationuuid || a.url;
        const bKey = b.stationuuid || b.url;
        const aTime = listeningTimes[aKey] || 0;
        const bTime = listeningTimes[bKey] || 0;
        return aTime - bTime;
      })
      .slice(0, 8);

    if (leastListenedStations.length < this.config.minStationsForBehavior) {
      return null;
    }

    return {
      id: 'least-listened',
      title: 'Rediscover These',
      stations: leastListenedStations,
      type: 'least-listened'
    };
  }

  /**
   * Generate recently added stations list
   */
  private generateRecentList(stations: LocalStation[]): AutoGeneratedList | null {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - this.config.recentDaysThreshold);
    const cutoffTime = cutoffDate.getTime();

    // Filter stations added within the threshold (use dateAdded if available, fallback to id timestamp or current time)
    const recentStations = stations
      .filter(station => {
        const addedTime = station.dateAdded 
          ? new Date(station.dateAdded).getTime()
          : (station.id ? parseInt(station.id) : Date.now());
        return addedTime >= cutoffTime;
      })
      .sort((a, b) => {
        // Sort by most recently added
        const aTime = a.dateAdded ? new Date(a.dateAdded).getTime() : (a.id ? parseInt(a.id) : 0);
        const bTime = b.dateAdded ? new Date(b.dateAdded).getTime() : (b.id ? parseInt(b.id) : 0);
        return bTime - aTime;
      })
      .slice(0, 8);

    if (recentStations.length < this.config.minStationsForBehavior) {
      return null;
    }

    return {
      id: 'recent-stations',
      title: 'Recently Added',
      stations: recentStations,
      type: 'recent'
    };
  }

  /**
   * Analyze listening patterns for a station
   */
  private analyzeListeningPatterns(stationId: string, listeningData: StationListeningTimes): { morningScore: number, eveningScore: number, nightScore: number, weekendScore: number, focusScore: number, quickSampleScore: number } {
    const data = listeningData[stationId];
    if (!data || !data.sessions || data.sessions.length === 0) {
      return { morningScore: 0, eveningScore: 0, nightScore: 0, weekendScore: 0, focusScore: 0, quickSampleScore: 0 };
    }

    let morningCount = 0;
    let eveningCount = 0;
    let nightCount = 0;
    let weekendCount = 0;
    let longSessions = 0;
    let quickSamples = 0;

    data.sessions.forEach(session => {
      const hour = session.hourOfDay;
      const dayOfWeek = session.dayOfWeek;
      const durationMinutes = session.duration / (1000 * 60);

      // Time-based analysis
      if (hour >= 5 && hour < 11) morningCount++;
      if (hour >= 18 && hour < 23) eveningCount++;
      if (hour >= 23 || hour < 5) nightCount++;

      // Weekend analysis (0 = Sunday, 6 = Saturday)
      if (dayOfWeek === 0 || dayOfWeek === 6) weekendCount++;

      // Session duration analysis
      if (durationMinutes >= 15) longSessions++;
      if (durationMinutes >= 0.5 && durationMinutes <= 3) quickSamples++;
    });

    const totalSessions = data.sessions.length;
    return {
      morningScore: morningCount / totalSessions,
      eveningScore: eveningCount / totalSessions,
      nightScore: nightCount / totalSessions,
      weekendScore: weekendCount / totalSessions,
      focusScore: longSessions / totalSessions,
      quickSampleScore: quickSamples / totalSessions
    };
  }

  /**
   * Generate behavioral analysis list based on time patterns
   */
  private generateBehavioralList(stations: LocalStation[], type: 'morning' | 'evening' | 'night' | 'weekend' | 'focus' | 'quickSample'): AutoGeneratedList | null {
    const listeningData = getStorageItem<StationListeningTimes>(StorageKeys.STATION_LISTENING_TIMES, {});
    
    // Check if we have sufficient data (at least N days of listening history)
    const cutoffTime = Date.now() - (this.config.minSessionDataDays * 24 * 60 * 60 * 1000);
    const hasRecentData = Object.values(listeningData).some(data => 
      data.lastPlayedAt && data.lastPlayedAt > cutoffTime
    );

    if (!hasRecentData) {
      return null;
    }

    const scoredStations = stations
      .filter(station => {
        const data = listeningData[station.stationuuid];
        return data && data.sessions && data.sessions.length >= 3; // Minimum 3 sessions
      })
      .map(station => {
        const patterns = this.analyzeListeningPatterns(station.stationuuid, listeningData);
        let score = 0;

        switch (type) {
          case 'morning':
            score = patterns.morningScore;
            break;
          case 'evening':
            score = patterns.eveningScore;
            break;
          case 'night':
            score = patterns.nightScore;
            break;
          case 'weekend':
            score = patterns.weekendScore;
            break;
          case 'focus':
            score = patterns.focusScore;
            break;
          case 'quickSample':
            score = patterns.quickSampleScore;
            break;
        }

        return { station, score };
      })
      .filter(item => item.score > 0.3) // Minimum 30% relevance
      .sort((a, b) => b.score - a.score)
      .slice(0, 8)
      .map(item => item.station);

    if (scoredStations.length < this.config.minStationsForBehavior) {
      return null;
    }

    const titles = {
      morning: 'Morning Favorites',
      evening: 'Evening Wind-Down',
      night: 'Night Owls',
      weekend: 'Weekend Vibes',
      focus: 'Focus Sessions',
      quickSample: 'Quick Samplers'
    };

    return {
      id: `behavioral-${type}`,
      title: titles[type],
      stations: scoredStations,
      type: 'behavioral'
    };
  }

  /**
   * Check if lists should be rotated based on rotation interval
   */
  private shouldRotateLists(): boolean {
    const rotationState = getStorageItem<ListRotationState>(StorageKeys.AUTO_GENERATED_LISTS_ROTATION_STATE, {
      lastRotation: 0,
      currentCycle: 0,
      rotationSeed: Math.random().toString(36).substring(2, 15),
      excludedCategories: []
    });

    const timeSinceLastRotation = Date.now() - rotationState.lastRotation;
    const rotationInterval = this.config.rotationIntervalDays * 24 * 60 * 60 * 1000;

    return timeSinceLastRotation > rotationInterval;
  }

  /**
   * Generate rotated list selection for discovery
   */
  private getRotatedListSelection(allLists: AutoGeneratedList[]): AutoGeneratedList[] {
    if (!this.shouldRotateLists()) {
      // Return lists based on existing rotation state
      const rotationState = getStorageItem<ListRotationState>(StorageKeys.AUTO_GENERATED_LISTS_ROTATION_STATE, {
        lastRotation: 0,
        currentCycle: 0,
        rotationSeed: Math.random().toString(36).substring(2, 15),
        excludedCategories: []
      });

      // Filter out excluded categories from this rotation
      const availableLists = allLists.filter(list => 
        !rotationState.excludedCategories.some(excluded => list.id.startsWith(excluded))
      );

      return availableLists.slice(0, this.config.maxLists);
    }

    // Time to rotate - select new set of lists
    const rotationState = getStorageItem<ListRotationState>(StorageKeys.AUTO_GENERATED_LISTS_ROTATION_STATE, {
      lastRotation: 0,
      currentCycle: 0,
      rotationSeed: Math.random().toString(36).substring(2, 15),
      excludedCategories: []
    });

    // Group lists by category
    const categoryGroups: { [key: string]: AutoGeneratedList[] } = {};
    allLists.forEach(list => {
      const category = list.type;
      if (!categoryGroups[category]) {
        categoryGroups[category] = [];
      }
      categoryGroups[category].push(list);
    });

    // Select categories for this rotation, excluding previously excluded ones
    const availableCategories = Object.keys(categoryGroups).filter(cat => 
      !rotationState.excludedCategories.includes(cat)
    );

    // If all categories have been excluded, reset the cycle
    if (availableCategories.length === 0) {
      rotationState.excludedCategories = [];
      rotationState.currentCycle++;
      availableCategories.push(...Object.keys(categoryGroups));
    }

    // Select lists from available categories, prioritizing diversity
    const selectedLists: AutoGeneratedList[] = [];
    const maxPerCategory = Math.max(1, Math.floor(this.config.maxLists / availableCategories.length));

    availableCategories.forEach(category => {
      const categoryLists = categoryGroups[category].slice(0, maxPerCategory);
      selectedLists.push(...categoryLists);
    });

    // Update rotation state
    const newExcludedCategory = availableCategories[Math.floor(Math.random() * availableCategories.length)];
    rotationState.excludedCategories.push(newExcludedCategory);
    rotationState.lastRotation = Date.now();

    setStorageItem(StorageKeys.AUTO_GENERATED_LISTS_ROTATION_STATE, rotationState);

    return selectedLists.slice(0, this.config.maxLists);
  }

  /**
   * Generate all auto-generated lists for the current station library
   */
  generateLists(stations: LocalStation[]): AutoGeneratedList[] {
    if (stations.length === 0) {
      return [];
    }

    // Get dismissal state
    const dismissedLists = getStorageItem<string[]>(StorageKeys.AUTO_GENERATED_LISTS_DISMISSED, []);

    // Generate all possible lists
    const candidateLists: AutoGeneratedList[] = [];
    
    // 1. Recently Added
    if (!dismissedLists.includes('recent-stations')) {
      const recentList = this.generateRecentList(stations);
      if (recentList) {
        candidateLists.push(recentList);
      }
    }
    
    // 2. Least Listened
    if (!dismissedLists.includes('least-listened')) {
      const leastListenedList = this.generateLeastListenedList(stations);
      if (leastListenedList) {
        candidateLists.push(leastListenedList);
      }
    }
    
    // 3. Country-based
    const countryList = this.generateCountryList(stations);
    if (countryList && !dismissedLists.includes(countryList.id)) {
      candidateLists.push(countryList);
    }
    
    // 4. Genre-based lists
    const genres = ['classical', 'jazz', 'rock'];
    for (const genre of genres) {
      const listId = `genre-${genre}`;
      if (!dismissedLists.includes(listId)) {
        const genreList = this.generateGenreList(stations, genre);
        if (genreList) {
          candidateLists.push(genreList);
        }
      }
    }

    // 5. Behavioral lists (Phase 3)
    if (this.config.behavioralAnalysisEnabled) {
      const behavioralTypes: Array<'morning' | 'evening' | 'night' | 'weekend' | 'focus' | 'quickSample'> = [
        'morning', 'evening', 'night', 'weekend', 'focus', 'quickSample'
      ];

      for (const type of behavioralTypes) {
        const listId = `behavioral-${type}`;
        if (!dismissedLists.includes(listId)) {
          const behavioralList = this.generateBehavioralList(stations, type);
          if (behavioralList) {
            candidateLists.push(behavioralList);
          }
        }
      }
    }
    
    // Apply rotation for discovery
    return this.getRotatedListSelection(candidateLists);
  }

  /**
   * Dismiss an auto-generated list
   */
  dismissList(listId: string): void {
    const dismissedLists = getStorageItem<string[]>(StorageKeys.AUTO_GENERATED_LISTS_DISMISSED, []);
    if (!dismissedLists.includes(listId)) {
      dismissedLists.push(listId);
      setStorageItem(StorageKeys.AUTO_GENERATED_LISTS_DISMISSED, dismissedLists);
    }
  }

  /**
   * Restore a dismissed auto-generated list
   */
  restoreList(listId: string): void {
    const dismissedLists = getStorageItem<string[]>(StorageKeys.AUTO_GENERATED_LISTS_DISMISSED, []);
    const updatedLists = dismissedLists.filter(id => id !== listId);
    setStorageItem(StorageKeys.AUTO_GENERATED_LISTS_DISMISSED, updatedLists);
  }

  /**
   * Get list of dismissed list IDs
   */
  getDismissedLists(): string[] {
    return getStorageItem<string[]>(StorageKeys.AUTO_GENERATED_LISTS_DISMISSED, []);
  }

  /**
   * Reset all dismissed lists (restore all auto-generated lists)
   */
  resetDismissedLists(): void {
    setStorageItem(StorageKeys.AUTO_GENERATED_LISTS_DISMISSED, []);
  }

}

// Export singleton instance
export const autoListGenerator = new AutoListGenerator();